@using GigaComic.Shared.Interfaces
@using GigaComic.Infrastructure.Extensions

@inject IJSRuntime js
﻿
@typeparam TItem where TItem : class, IDraggable

<Spin Spinning="isSaveInProcess">
    <div class="dragdrop d-flex" ondragover="event.preventDefault();">
        @foreach (var item in Items)
        {
            @if (ItemTemplate is not null)
            {
                <div class="dragdrop__item"
                     draggable="true"
                     @key="Items.IndexOf(item)"
                     @ondrop="@(async () => await Drop(item))"
                     @ondrag="@(()=> Drag(item))"
                     id="dragDropItem_@(item.Order)">
                    @ItemTemplate(item)
                </div>
            }
        }
    </div>
</Spin>

@code {
    [Parameter]
    public RenderFragment<TItem>? ItemTemplate { get; set; }

    [Parameter]
    public List<TItem> Items { get; set; } = new();

    [Parameter]
    public EventCallback OrderChangedCallback { get; set; }

    [Parameter]
    public EventCallback<long> DeleteItemCallback { get; set; }

    private TItem? _currentDragged = null;
    private int currentIndex;
    private bool isSaveInProcess = false;
    private Queue<string> _queueInit = new();
    private bool _needInit = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            await InitDragEvents();

        if (!firstRender && _queueInit.Count > 0)
            while(_queueInit.TryDequeue(out var realId))
                await RealInitDragEvent(realId);

        await base.OnAfterRenderAsync(firstRender);
    }

    public async Task InitDragEvents()
    {
        await js.InvokeVoidAsync("initDragEvents");
    }

    public async Task InitDragEvent(string id)
    {
        var realId = $"dragDropItem_{id}";
        _queueInit.Enqueue(realId);
    }

    async Task RealInitDragEvent(string realId)
    {
        await js.InvokeVoidAsync("initDragEventById", realId);
    }

    void Drag(TItem item)
    {
        currentIndex = GetIndex(item);
    }

    void ClickItem(TItem item)
    {
        currentIndex = GetIndex(item);
    }

    int GetIndex(TItem item)
    {
        return Items.IndexOf(item);
    }

    async Task Drop(TItem item)
    {
        isSaveInProcess = true;
        await Task.Run(() => { InvokeAsync(StateHasChanged); });

        if (item != null)
        {
            var index = GetIndex(item);

            var current = Items[currentIndex];

            if (index != currentIndex)
            {
                Items.Swap(currentIndex, index);

                for (var i = 0; i < Items.Count; i++)
                    Items[i].Order = i;

                currentIndex = index;

                await OrderChangedCallback.InvokeAsync();
            }

        }

        isSaveInProcess = false;
        await Task.Run(() => { InvokeAsync(StateHasChanged); });
    }
}
